---
layout: post
title:  ä½¿ç”¨å‘é‡æ•°æ®åº“æ­å»ºè‡ªå·±çš„RAG
date:   2025-06-27 10:30:00 +0800
categories: essay
tag: note
---

* content
{:toc}

## åŸºç¡€ä»‹ç»
> æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰æ˜¯æŒ‡å¯¹å¤§å‹è¯­è¨€æ¨¡å‹è¾“å‡ºè¿›è¡Œä¼˜åŒ–ï¼Œä½¿å…¶èƒ½å¤Ÿåœ¨ç”Ÿæˆå“åº”ä¹‹å‰å¼•ç”¨è®­ç»ƒæ•°æ®æ¥æºä¹‹å¤–çš„æƒå¨çŸ¥è¯†åº“

- ä»€ä¹ˆæ˜¯RAG
- ä¸ºä»€ä¹ˆéœ€è¦RAG
- RAGå’ŒLLMçš„å…³ç³»

å‚è€ƒæ–‡æ¡£ ä¼ é€é—¨ğŸ‘‰ [What is RAG](https://aws.amazon.com/what-is/retrieval-augmented-generation/)

## ä¾èµ–ä»‹ç»
> ä¸Šä¸€æ¬¡æˆ‘ä»¬ä½¿ç”¨Difyæ­å»ºäº†è‡ªå·±çš„çŸ¥è¯†åº“ï¼Œå…¶å®è¿™æ¬¡æˆ‘ä»¬è¦åšçš„å°±æ˜¯è‡ªå·±å®ç°è¿™ä¸€å¥—

- å‘é‡æ•°æ®åº“ï¼š[milvus](https://github.com/milvus-io/milvus)
- æœ¬åœ°å¤§æ¨¡å‹éƒ¨ç½²å·¥å…·ï¼š[ollama](https://ollama.com)
- ä¾èµ–æ¨¡å‹ï¼š
    - LLMæ¨¡å‹ï¼šdeepseek-r1:8b
    - Embeddingæ¨¡å‹ï¼šbge-m3 
- å¼€å‘è¯­è¨€ï¼šgolang

å®ç°æµç¨‹å¦‚ä¸‹:
1. çŸ¥è¯†åº“æºæ–‡ä»¶Doc filesé€šè¿‡Embeddingæ¨¡å‹å°†æ•°æ®å‘é‡åŒ–ä¹‹åå­˜å…¥å‘é‡æ•°æ®åº“milvus
2. ç”¨æˆ·æé—®ï¼Œé€šè¿‡Embeddingæ¨¡å‹å°†é—®é¢˜å‘é‡åŒ–å¬å›æŸ¥è¯¢æ•°æ®ï¼Œå°†æ•°æ®å’Œé—®é¢˜åˆå¹¶ä¸Šä¸‹æ–‡ï¼ˆä¼˜åŒ–æç¤ºè¯ï¼‰æä¾›ç»™LLMå¤§æ¨¡å‹ï¼Œæœ€ç»ˆé€šè¿‡SSEäº‹ä»¶æµå“åº”ç»™å®¢æˆ·ç«¯


![Naive RAG](../styles/images/2025/06-27/image.png)

## å¼€å‘å®ç°
> ä»¥ä¸‹æ˜¯ä¸€äº›å…³é”®æ­¥éª¤çš„å®ç°

### åˆå§‹åŒ–å‘é‡æ•°æ®åº“ï¼Œå»ºç«‹ç´¢å¼•
```// InitDB åˆå§‹åŒ–æ•°æ®åº“ï¼Œåˆ›å»ºcollectionã€ç´¢å¼•
func InitDB(ctx context.Context) error {
	cli, err := InitMilvus(ctx)
	if err != nil {
		return fmt.Errorf("failed to initialize Milvus client: %v", err)
	}
	defer cli.Close(ctx)
	has, _ := cli.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if has {
		// æµ‹è¯•çš„æ—¶å€™å¯ä»¥åˆ é™¤é‡æ–°åˆ›å»º
		log.Println("å·²å­˜åœ¨åŒåé›†åˆï¼Œæ­£åœ¨åˆ é™¤...")
		_ = cli.DropCollection(ctx, milvusclient.NewDropCollectionOption(collectionName))
		//return nil
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("vector").WithDataType(entity.FieldTypeFloatVector).WithDim(int64(1024))).
		WithField(entity.NewField().WithName("text").WithDataType(entity.FieldTypeVarChar).WithMaxLength(2048)).
		WithField(entity.NewField().WithName("fileID").WithDataType(entity.FieldTypeVarChar).WithMaxLength(64)).
		WithField(entity.NewField().WithName("userID").WithDataType(entity.FieldTypeVarChar).WithMaxLength(64))
	opts := milvusclient.NewCreateCollectionOption(collectionName, schema)

	err = cli.CreateCollection(ctx, opts)
	if err != nil {
		return fmt.Errorf("failed to create collection: %v", err)
	}

	hnswIndex := index.NewHNSWIndex(entity.COSINE, 8, 200)
	createIndexOption := milvusclient.NewCreateIndexOption(collectionName, "vector", hnswIndex)

	// åˆ›å»ºç´¢å¼•
	_, err = cli.CreateIndex(context.Background(), createIndexOption)
	if err != nil {
		log.Fatal("failed to create index:", err.Error())
		return err
	}

	// æ·»åŠ å¯¹ userID å­—æ®µçš„ç´¢å¼•åˆ›å»ºé€»è¾‘
	userIDIndexOption := milvusclient.NewCreateIndexOption(collectionName, "userID", index.NewInvertedIndex())
	_, err = cli.CreateIndex(context.Background(), userIDIndexOption)
	if err != nil {
		log.Fatal("failed to create index for userID field:", err.Error())
		return err
	}

	return nil
}
```

### åŸå§‹æ•°æ®å‘é‡åŒ–ï¼Œå»ºç«‹çŸ¥è¯†åº“
```
type processResult struct {
	filePath string
	err      error
	duration time.Duration
	workerID int
}

func ProcessDocuments() error {
	ctx := context.Background()
	err := InitDB(ctx)
	if err != nil {
		return fmt.Errorf("åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥: %v", err)
	}

	// é…ç½®å‚æ•°
	dir := "./docs"
	userID := "default"
	maxConcurrency := runtime.NumCPU() * 2                // æ ¹æ®CPUæ ¸å¿ƒæ•°åŠ¨æ€è®¾ç½®å¹¶å‘æ•°
	fileTypes := []string{".txt", ".md", ".pdf", ".docx"} // æ”¯æŒçš„æ–‡ä»¶ç±»å‹

	log.Printf("å¼€å§‹æ‰«ææ–‡æ¡£ç›®å½•: %s", dir)

	// è·å–æ–‡ä»¶åˆ—è¡¨
	files, err := findFiles(dir, fileTypes)
	if err != nil {
		return fmt.Errorf("æŸ¥æ‰¾æ–‡ä»¶å¤±è´¥: %v", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("æœªæ‰¾åˆ°å¯å¤„ç†çš„æ–‡ä»¶")
	}

	log.Printf("æ‰¾åˆ° %d ä¸ªæ–‡æ¡£å¾…å¤„ç†", len(files))

	// åˆ›å»ºå¤„ç†é€šé“å’Œç­‰å¾…ç»„
	fileChan := make(chan string, maxConcurrency)
	resultChan := make(chan processResult, len(files))
	var wg sync.WaitGroup

	// å¯åŠ¨å·¥ä½œæ± 
	for i := 0; i < maxConcurrency; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			for filePath := range fileChan {
				select {
				case <-ctx.Done():
					resultChan <- processResult{filePath: filePath, err: ctx.Err()}
					return
				default:
					start := time.Now()
					err := processSingleFile(ctx, filePath, userID, workerID)
					duration := time.Since(start)
					resultChan <- processResult{
						filePath: filePath,
						err:      err,
						duration: duration,
						workerID: workerID,
					}
				}
			}
		}(i)
	}

	// å‘é€æ–‡ä»¶åˆ°é€šé“
	go func() {
		for _, file := range files {
			select {
			case fileChan <- file:
			case <-ctx.Done():
				return
			}
		}
		close(fileChan)
	}()

	// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// å¤„ç†ç»“æœå¹¶æ˜¾ç¤ºè¿›åº¦
	startTime := time.Now()
	processed := 0
	successes := 0
	failures := 0
	lastUpdate := time.Now()

	for result := range resultChan {
		processed++

		if result.err != nil {
			failures++
			log.Printf("[Worker %d] å¤„ç†å¤±è´¥: %s | é”™è¯¯: %v | è€—æ—¶: %v",
				result.workerID, filepath.Base(result.filePath), result.err, result.duration.Round(time.Millisecond))
		} else {
			successes++
			log.Printf("[Worker %d] å¤„ç†æˆåŠŸ: %s | è€—æ—¶: %v",
				result.workerID, filepath.Base(result.filePath), result.duration.Round(time.Millisecond))
		}

		// å®šæœŸæ›´æ–°è¿›åº¦
		if time.Since(lastUpdate) > 5*time.Second || processed == len(files) {
			log.Printf("è¿›åº¦: %d/%d (%.1f%%) | æˆåŠŸ: %d | å¤±è´¥: %d",
				processed, len(files), float64(processed)/float64(len(files))*100,
				successes, failures)
			lastUpdate = time.Now()
		}
	}

	duration := time.Since(startTime)
	log.Printf("å¤„ç†å®Œæˆ! æ€»æ•°: %d | æˆåŠŸ: %d | å¤±è´¥: %d | æ€»è€—æ—¶: %v",
		len(files), successes, failures, duration.Round(time.Second))

	if failures > 0 {
		return fmt.Errorf("éƒ¨åˆ†æ–‡ä»¶å¤„ç†å¤±è´¥ (%d/%d)", failures, len(files))
	}
	return nil
}

// æŸ¥æ‰¾æŒ‡å®šç±»å‹çš„æ–‡ä»¶
func findFiles(dir string, extensions []string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("è®¿é—®è·¯å¾„é”™è¯¯: %s, é”™è¯¯: %v", path, err)
			return nil // è·³è¿‡é”™è¯¯æ–‡ä»¶ï¼Œç»§ç»­å¤„ç†
		}

		if !info.IsDir() {
			ext := strings.ToLower(filepath.Ext(path))
			for _, allowed := range extensions {
				if ext == allowed {
					files = append(files, path)
					break
				}
			}
		}
		return nil
	})
	return files, err
}

// å¤„ç†å•ä¸ªæ–‡ä»¶
func processSingleFile(ctx context.Context, filePath, userID string, workerID int) error {
	// æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦å·²å–æ¶ˆ
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	// è·å–æ–‡ä»¶ID (ä½¿ç”¨ç›¸å¯¹è·¯å¾„ä½œä¸ºå”¯ä¸€ID)
	relPath, err := filepath.Rel("./docs", filePath)
	if err != nil {
		return fmt.Errorf("è·å–ç›¸å¯¹è·¯å¾„å¤±è´¥: %v", err)
	}
	fileID := strings.ReplaceAll(relPath, string(filepath.Separator), "_")

	// è¯»å–æ–‡ä»¶å†…å®¹
	content, err := ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
	}
	if content == "" {
		return fmt.Errorf("ç©ºæ–‡ä»¶")
	}

	// å‘é‡åŒ–æ–‡æœ¬ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
	vectorChan := make(chan []float32, 1)
	errChan := make(chan error, 1)

	go func() {
		vector, err := EmbedText(content)
		if err != nil {
			errChan <- err
			return
		}
		vectorChan <- vector
	}()

	select {
	case <-ctx.Done():
		return ctx.Err()
	case err := <-errChan:
		return fmt.Errorf("å‘é‡åŒ–å¤±è´¥: %v", err)
	case vector := <-vectorChan:
		// å­˜å‚¨æ–‡æ¡£
		if err := StoreDocument(fileID, userID, content, vector); err != nil {
			return fmt.Errorf("å­˜å‚¨å¤±è´¥: %v", err)
		}
		return nil
	case <-time.After(2 * time.Minute): // å‘é‡åŒ–è¶…æ—¶æ—¶é—´
		return fmt.Errorf("å‘é‡åŒ–è¶…æ—¶")
	}
}
func ReadFile(path string) (string, error) {
	// è¯»å–æ–‡ä»¶å†…å®¹
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(data), nil
}
```

### æç¤ºè¯ä¼˜åŒ–
```
const ragPromptTemplate = `[INST] <<SYS>>
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„çŸ¥è¯†é—®ç­”åŠ©æ‰‹ã€‚è¯·æ ¹æ®æä¾›çš„<å‚è€ƒä¿¡æ¯>å›ç­”é—®é¢˜ï¼Œä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š
1. ç­”æ¡ˆå¿…é¡»å®Œå…¨åŸºäº<å‚è€ƒä¿¡æ¯>å†…å®¹ç”Ÿæˆ
2. å¦‚æœå‚è€ƒä¿¡æ¯ä¸åŒ…å«ç­”æ¡ˆæ‰€éœ€å†…å®¹ï¼Œå¿…é¡»æ˜ç¡®è¯´æ˜"æ ¹æ®æä¾›çš„ä¿¡æ¯æ— æ³•å›ç­”"
3. ä¿æŒç­”æ¡ˆç®€æ´ä¸“ä¸šï¼Œé¿å…ä¸»è§‚æ¨æµ‹
4. ä½¿ç”¨ä¸­æ–‡å›ç­”
5. å¦‚æœé—®é¢˜ä¸å‚è€ƒä¿¡æ¯æ— å…³ï¼Œç›´æ¥è¯´æ˜æ— æ³•å›ç­”
<</SYS>>

# å‚è€ƒä¿¡æ¯ï¼š
{{.Context}}

# ç”¨æˆ·é—®é¢˜ï¼š
{{.Question}}

è¯·æ ¹æ®ä»¥ä¸Šå‚è€ƒä¿¡æ¯å›ç­”ç”¨æˆ·é—®é¢˜ã€‚[/INST]
`
```

### å‰ç«¯SSEå®ç°ä¸»è¦ä¾èµ–EventSource
```
// åˆ›å»ºä¸€ä¸ª EventSource å¯¹è±¡æ¥æ¥æ”¶ SSE æµ
const eventSource = new EventSource(`/ask?userID=${encodeURIComponent(userID)}&query=${encodeURIComponent(query)}`);

// ç›‘å¬æ¶ˆæ¯äº‹ä»¶
eventSource.onmessage = function(event) {}

// ç›‘å¬é”™è¯¯äº‹ä»¶
eventSource.onerror = function(event) {}
```

## æ€»ç»“å®ç°
> ç†æƒ³åŒ–çš„RAGå®ç°æµç¨‹æ­£å¦‚ä¸Šé¢çš„æµç¨‹å›¾ï¼Œç®€å•æ˜äº†ï¼Œä½†æ˜¯å…·ä½“å®ç°ä»¥åŠä¼ä¸šçº§ç”Ÿäº§è½åœ°è¿˜éœ€è¦é¢ä¸´å¾ˆå¤šé—®é¢˜
1. ä¸åŒæ ¼å¼æ–‡ä»¶çš„å¤„ç†ï¼ˆPDF,Word,EPUB,MarkDownç­‰ï¼‰
2. è¯­éŸ³æœç´¢å’Œæ··åˆæœç´¢ï¼Œåœ¨æœ‰å¤§é‡æ–‡æ¡£çš„æƒ…å†µä¸‹ï¼Œè¯­ä¹‰ç›¸ä¼¼çš„åŒ¹é…ç»“æœå¤ªå¤šäº†ï¼›ç”¨æˆ·å¯èƒ½æƒ³è¦æœ€æ–°çš„ä¿¡æ¯ï¼Œè€Œä¸ä»…ä»…æ˜¯è¯­ä¹‰æœ€ç›¸ä¼¼çš„ä¿¡æ¯ï¼›ä¸¢å¤±äº†æ–‡æ¡£ä¸­ä¸æœç´¢ç›¸å…³çš„é‡è¦ç»“æ„ä¿¡æ¯ï¼Œä¾‹å¦‚æ ‡é¢˜ã€é¡µç ç­‰.
3. åˆ†å—Chunkingï¼šå‘é‡æ•°æ®åº“éœ€è¦å°†æ–‡æ¡£åˆ†å‰²æˆå—ï¼Œä»¥ä¾¿æ£€ç´¢å’Œç”Ÿæˆæç¤º.æ ¹æ®æ–‡æ¡£çš„åˆ†å—æ–¹å¼ï¼Œç›¸åŒçš„æŸ¥è¯¢å°†è¿”å›ä¸åŒçš„å†…å®¹.
4. å¤šæ¨¡æ€ï¼šå›¾ç‰‡ã€éŸ³è§†é¢‘ç­‰ç­‰
